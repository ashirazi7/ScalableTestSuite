within ScalableTestSuite.Power;
package ConceptualPowerSystem
  "Conceptual model of a power system that reproduces some of its key dynamic features"
  package Models
    model Generator
      constant Real pi = Modelica.Constants.pi;
      parameter SI.Power P_nom = 500e6 "Nominal power of the generator";
      parameter SI.Frequency f_ref = 50 "Reference network frequency";
      parameter SI.Time T_a = 5 "Characteristic time of the generator";
      parameter SI.PerUnit alpha = 0.3
        "Fraction of turbine power provided by the high-pressure turbine";
      parameter SI.Time tau_b = 200
        "Characteristic time of energy storage in the boiler";
      parameter SI.Time tau_t = 8
        "Characteristic response time of the low pressure turbine";
      parameter SI.Time tau_q = 3
        "Characteristic time of thermal generation process";
      parameter SI.Time tau_y = 0.3 "Characteristic time of turbine governor";
      parameter SI.PerUnit droop = 0.05 "Primary frequency control droop";
      parameter SI.PerUnit Kp_p = 10 "Proportional gain of pressure controller";
      parameter SI.Time Ti_p = 70 "Integral time of pressure controller";
      parameter SI.PerUnit Kp_t = 2 "Proportional gain of power controller";
      parameter SI.Time Ti_t = 0.3 "Integral time of power controller";
      final parameter SI.AngularVelocity omega_ref = 2*pi*f_ref;
      final parameter SI.MomentOfInertia J = P_nom*T_a/(omega_ref^2);
       SI.Power P_a = P_nom
        "Active electrical power produced by the synchronous generator - replace the default binding";
      SI.Power P_t_0 = P_nom
        "Active power set point - replace the default binding";
      SI.Power P_t "Mechanical power generated by the turbine [W]";
      SI.Angle theta
        "Rotor angle relative to reference rotating at nominal speed";
      SI.AngularVelocity omega "Turbine angular speed";
      SI.Frequency f "Generator frequency";
      SI.PerUnit delta_f "Normalized frequency error";
      SI.PerUnit p "Boiler pressure in p.u.";
      SI.PerUnit p_0 = 1 "Boiler pressure set point in p.u.";
      SI.PerUnit w_s "Steam flow rate in p.u.";
      SI.PerUnit q_ev "Thermal power to the boiler in p.u.";
      SI.PerUnit q_ev_0 "Thermal power set point in p.u.";
      SI.PerUnit y_t "Turbine admittance in p.u";
      SI.PerUnit y_t_0 "Turbine admittance set point in p.u.";
      SI.PerUnit p_t "Turbine power in p.u.";
      SI.PerUnit p_t_0 "Turbine power set point in p.u.";
      SI.PerUnit p_t_lp "Low-pressure turbine power in p.u.";

      SI.PerUnit err_p_t "Power controller error in p.u.";
      SI.PerUnit err_p_t_int "Integral of power controller error";

      SI.PerUnit err_p "Pressure controller error in p.u.";
      SI.PerUnit err_p_int "Pressure controller integral error";

    equation
      // Rotor phase angle equation (relative to reference rotating at reference speed)
      der(theta) = omega - omega_ref;

      // Energy balance on the turbine-generator axis
      der(J*omega^2/2) = P_t - P_a;

      // Non-dimensional boiler model
      tau_b*der(p) = q_ev - w_s;

      // Non-dimensional turbine model
      w_s = y_t*p "steam flow";
      tau_t*der(p_t_lp) + p_t_lp = (1-alpha)*w_s "LP turbine power";
      p_t = alpha *w_s + p_t_lp "Total turbine power";

      // Actuation
      tau_y*der(y_t) = y_t_0 - y_t;
      tau_q*der(q_ev) = q_ev_0 - q_ev;

      // Normalization equations
      P_t = p_t*P_nom;
      P_t_0 = p_t_0*P_nom;

      // Boiler follows control strategy with primary frequency control
      f = omega/(2*pi);
      delta_f = (f - f_ref)/f_ref;

      err_p_t = p_t_0 - p_t - 1/droop*delta_f;
      der(err_p_t_int) = err_p_t;

      err_p = p_0 - p;
      der(err_p_int) = err_p;

      q_ev_0 = p_t_0 + Kp_p*(err_p + 1/Ti_p * err_p_int);
      y_t_0 = p_t_0 - 1/droop*delta_f + Kp_t*(err_p_t + 1/Ti_t *err_p_t_int);

    initial equation
      theta = 0;
      omega = omega_ref;
      p = 1;
      p_t_lp = (1-alpha);
      y_t = 1;
      q_ev = 1;
      err_p_t_int = 0;
      err_p_int = 0;
    end Generator;

    model PowerSystem
      parameter Integer N = 1 "Number of nodes on the longitudinal direction";
      parameter SI.Power P_nom = 500e6 "Nominal power of a single generator";
      parameter SI.AngularVelocity omega_ref = 2*pi*50;
      constant Real pi = Modelica.Constants.pi;
      SI.Power P_load[N] = ones(N)*P_nom
        "Active power consumed by loads - replace the default binding";
      SI.Power P_ex[N,N] "Power going from generator i to generator j";
      SI.Power P_diss[N,N] "Power dissipated by the generators i and j";
      SI.Power P_a[N] "Net active power out of generator i";
      SI.Power P_f = 5*P_nom
        "Power factor of a single trunk of transmission line";
      Real P_d = 0.5*P_nom/omega_ref "Power dissipation coefficient";
      Generator generator[N](each P_nom = P_nom,
                             P_a = P_a);
    equation
      for i in 1:N loop
        P_a[i] = sum(P_ex[i,:]) + sum(P_diss[i,:]) + P_load[i];
        for j in 1:N loop
          if i == j then
            P_ex[i,j] = 0;
            P_diss[i,j] = 0;
          else
            P_ex[i,j] = P_f/(abs(i-j))*sin(generator[i].theta-generator[j].theta);
            P_diss[i,j] = P_d*(generator[i].omega - generator[j].omega);
          end if;
        end for;
      end for;
    end PowerSystem;
  end Models;

  package Verification

    model OneGeneratorConstantLoad
      "One generator with constant load at equilibrium"
      extends Models.PowerSystem(generator(each P_t_0=P_nom), P_load=P_nom*ones(N));
    end OneGeneratorConstantLoad;

    model OneGeneratorStepLoad
      "One generator with 1% step reduction from equilibrium"
      extends OneGeneratorConstantLoad(
        P_load=cat(1, {P_nom*0.99}, P_nom*ones(N - 1)));
      annotation (experiment(StopTime=500, Tolerance=1e-006),
          __Dymola_experimentSetupOutput(equidistant=false));
    end OneGeneratorStepLoad;

    model TwoGeneratorsConstantLoad
      "One generator with constant load at equilibrium"
      extends Models.PowerSystem(
        N = 2,
        generator(each P_t_0=P_nom), P_load=P_nom*ones(N));
    end TwoGeneratorsConstantLoad;

    model TwoGeneratorsStepLoad
      "One generator with 1% step reduction from equilibrium"
      extends TwoGeneratorsConstantLoad(
        P_load=cat(1, {P_nom*0.99}, P_nom*ones(N - 1)));
      annotation (experiment(StopTime=500, Tolerance=1e-006),
          __Dymola_experimentSetupOutput(equidistant=false));
    end TwoGeneratorsStepLoad;
  end Verification;

  package ScaledExperiments

  end ScaledExperiments;
end ConceptualPowerSystem;
